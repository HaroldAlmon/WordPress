<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Dawn</title>
</head>
<body>
<h3>The IBM PC is Born</h3>
<p>I have been around long enough that I remember the world before the personal computer even existed. When it arrived, the IBM PC had 64 KB, that's kilobytes, of memory, no hard drive, and a single sided 5.25 inch low capacity floppy drive. I know, my friend Bill had bought one with a printer for the astounding price of around $5,000 CDN. At the time you could by a hamburger, fries, and a drink at MacDonald's and get back change from a one dollar bill.  

Bill was a drummer in a Ukrainian band which is where he got the money to purchase this expensive machine. Here is an IBM PC model that I received for free in 1983 when I attended a show for financial institutions that demonstrated teller terminal equipment. IBM was the competition but they were nice enough to give me the model when I asked for one.</p>
[caption id="attachment_1675" align="aligncenter" width="1333"]<a href="http://www.translationdata.com/wp-content/uploads/2015/11/IMG_3841-e1447517812505.jpg"><img class="wp-image-1675 size-full" src="http://www.translationdata.com/wp-content/uploads/2015/11/IMG_3841-e1447517812505.jpg" alt="IBM PC Model 1983" width="1333" height="1000" /></a> IBM PC Model 1983[/caption]
<p>The IBM PC had an 8 bit bus and the company I worked for, Olivetti, had a competing model with a 16 bit bus based on the Inter 8086 CPU. This meant that data could be transferred from memory at twice the speed of the IBM PC.</p>
<h3>Teller Terminals in the 1980's</h3>
<p>Olivetti also had a spanking brand new L1 Series teller terminal system was based on the Zilog Z8000 chip running at 4 Mhz that came configured in a machine with 128 KB of memory. Wow, this new model had twice the memory of the previous machine! Time passed and the CPU was upgraded to 8 Mhz and the memory board made to at least 512K if not one megabyte of memory. You cannot even store an mp3 file in that amount of memory but these machines actually ran in retail banks complete with internal and external communication lines running IBM's SNA/SDLC communications protocol. 

The previous <a href="http://www.computerhistory.it/index.php?option=com_content&amp;view=category&amp;id=17&amp;Itemid=63" target="_blank">Olivetti teller terminal machin</a>e had a board of integrated circuits and ran an interpreted assembly language called LIMO that stood for Linguaggio Interattivo Macchina Olivetti (Olivetti Machine Interactive Language). Since Olivetti was Italian, the words were reversed hence the LIMO acronym. LIMO was not even an assembly language, just a collection of instructions that looked like assembly instructions and were either interpreted by the hardware or converted to lower level instructions. Sorry, I do not have the technical details as to how it actually worked. 

I only wrote one LIMO program and only remember one instruction, BRA, that stood for Branch Return Address, basically a return statement that could jump past the calling address by a fixed number of bytes. The idea was that you would put a goto error routine instruction after the call and the called procedure would return past that address if there was no error (BRA 2) else return to the goto error instruction (BRA 0). This is definitely one of the weirdest assembly language statements I have every seen.  I tried to find a sample LIMO program but sadly, I could not find one. 

That machine reached it's end of life when the memory topped out at 64 KB. The machine talked to a hard drive the size of a small file cabinet that contained a few megabytes of disk space. The L1 Series of machines came from Italy with with a LIMO emulator so that the new machines could run applications written for the previous hardware. 

I was working in Olivetti Canada at the time and that company decided that it was going to run application in native Z8000 mode so we essential wrote an operating system from scratch call L1SA. This caused confusion when apple released a PC called LISA so L1SA was eventually renamed to L1ON (L1 Online Network). This proved to be a fortuitous choice because the the L1ON system provide much quicker response times that the LIMO emulator. 

The users loved the system because the system was extremely responsive. You pressed a key and screen responded immediately. This was due to a design goal of providing a responsive system and the fact that the screen was character based. The graphical systems of today look nice but we all pay a price in terms of response time. 

The L1ON system supported multiple users without a thread system which was quite amazing at the time. Just like other developers, we eventually ran out of memory and got upgrades to 256K and later 512K memory boards.  I think the system may have topped out with 1024K memory boards but I am not sure. Now, you cannot even load an mp3 file into 1024K of memory. 

What software was available in this era? WordPerfect, Lotus 123, Visicalc, and Harvard Graphics. I only used Visicalc and it was quite primitive with fixed width cells. These programs were the leaders back then but Microsoft entered the market with a suite of tools that offered integration. Maybe the applications were not the best in their category but it is what the customers wanted. Microsoft captured the majority of the market sealing the fate of the first movers.</p>
<h3>Moore's Law</h3>
<p>In the 1980's PC's, transistor count doubled about every 18-24 months. This doubling was known as Moore's law.  CPU speeds and memory also increased. The increase in computation power has continued for the thirty-five years post 1980 but is finally slowing down as chip manufacturers hit fundamental physical limits.</p>
<h3>The Future is Parallel</h3>
<p>So what are computer manufacturers going to do when the cores inside of the computers stop increasing in terms of throughput? One solution is to run multiple cores in a computer and another is to distribute workloads across server farms. Hadoop was one of the big successes of distributed computing and it appears that Apache Spark is going to succeed Hadoop. To make multiple core systems viable, we need software that exploits the availability of multiple cores. 

Simon Peyton Jones has a video called <a href="https://www.youtube.com/watch?v=hlyQjK1qjw8" target="_blank">The Future is Parallel, the Future of Parallel is Declarative</a>. In the video, Simon discusses issues that language designers face when trying to run software application programs in parallel. Simon is one of the key contributors to the Haskell language that he believes is built from the ground up to run programs in parallel. 

Java 8 and Scala, among other languages, have adopted functional programming features from Haskell. The result is that Java 8 has lambda expressions and stream support built into the language. Scala was built to offer both imperative and functional programming features. In addition, Scala runs on the battle proven Java JVM so it is highly compatible with the Java ecosystem. 
</body>
</html>